---
layout: post
title: Building and Debugging the Linux Kernel
excerpt: Get started with this walkthrough of kernel basics
categories: articles
tags: [linux,kernel,build,debug,qemu,virtualmachine,virtualbox]
comments: true
share: true
ads: true
redirect_from: ['/post/111225498909/build-debug-linux-kernel/', '/post/111225498909/']
---

<p>Recently, for the first time in a few months, I had built the latest version of the <a href="http://kernel.org/" target="_blank">Linux kernel</a>. In fact, since I don&rsquo;t drink coffee, I decided to write this post while I waited for it to build. We&rsquo;ll take a quick look through where to get the <i>official</i> source code, how to compile it, and what tools there are to debugging it (short of rebooting your machine for every patch, of course). That said, I will shift much of the focus of this article on to actually running the built kernel and debugging it.</p><h2>Where&rsquo;s teh codez?</h2><p>The <i>official</i> linux source tree can be found at <a href="http://kernel.org/" target="_blank">Kernel.org</a>. From here you can download the source in tarball form or take the latest release (at time of writing, this is kernel v3.19 which is the tag I checked out). However, I recommend ingesting your source via <a href="http://git-scm.org/" target="_blank">git</a>. Using git allows you to keep the tree up-to-date with the latest revisions and checkout any previous version of kernel source that you care about. In particular, I recently grabbed the source directly from the <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/" target="_blank">torvalds/linux.git</a> repo. You will want to run:</p><blockquote>git clone <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/" target="_blank">https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/</a><br/></blockquote><p>Once you have this copy of the source code, you can move around to any source revision you like or take a tagged build. To see a list of available tags, cd into the source directory and try:</p><blockquote>git tag -l<br/></blockquote><p>Great, this is the first step to building your kernel. If you want more help with git, see <a href="http://linuxandfriends.com/a-git-primer-for-new-users/" target="_blank">this git primer</a> or try to search around for others. There are <b>many</b> git resources available out there.</p><h2>Building the Kernel</h2><p>Since we&rsquo;re ready with our source code, we can build the kernel. Building the kernel is reasonably straightforward if you&rsquo;re familiar with typical Makefile projects, but there are <a href="http://kernelnewbies.org/KernelBuild" target="_blank">other resources</a> that also contain more detail on this.</p><p><b>Ramdisk (optional).</b> The first thing I like to do is create a <a href="http://en.wikipedia.org/wiki/RAM_drive" target="_blank">ramdisk</a>. I have found that about 3GB is sufficient for this size. You can try to run something like the following to create a ram disk at the location of <i>/media/ramdisk</i>:</p><blockquote>sudo mkdir -p /media/ramdisk<br/>sudo mount -t tmpfs -o size=3072M tmpfs /media/ramdisk<br/># The next command copies the repo over<br/>cp linux /media/ramdisk</blockquote><p>This improves the overall performance of the build since it can write the compiled code and read the source files out of RAM instead of off disk (i.e. disk is orders of magnitudes slower than memory). However, the initial copying of source will take some time since it is reading from disk and copying into memory.</p><blockquote><b>NOTE:</b> This is an optimization and in no way necessary for compiling the Linux kernel. Likewise, upon reboot, the contents of the RAM disk will be cleared (since RAM is <i><a href="http://en.wikipedia.org/wiki/Volatile_memory" target="_blank">volatile</a></i> storage).<br/></blockquote><blockquote><b>Caveat: </b>Though I recommend performing all of your builds on your RAM disk for speed, this does cause an obvious <i>synchronization</i> problems between the files on your disk and the files in your ram disk. I will leave the coping mechanism to you if you&rsquo;re performing active development, but one feasible solution is to simply continue using git to track your changes (perhaps an alternate remote would be useful here). Just be sure to <i><b>push</b></i> your changes before you delete the ram disk or reboot.</blockquote><p><b>Configuring the Kernel. </b>The next step in the process is to create a configuration. You can use your current kernel&rsquo;s configuration or use the default one. </p><blockquote>make defconfig<br/></blockquote><p>The above command will create a default kernel configuration for you. Alternatively, you can use <i>make menuconfig</i> instead to manually configure your kernel. Open up the generated configuration (i.e. the <i>.config</i> file) and make sure you have set the following parameters (for debugging):</p><blockquote>CONFIG_FRAME_POINTER=y<br/>CONFIG_KGDB=y<br/>CONFIG_KGDB_SERIAL_CONSOLE=y<br/>CONFIG_DEBUG_INFO=y</blockquote><p><b>Build the kernel. </b>After that, you&rsquo;ll want to actually build the kernel. The machine I&rsquo;m using to compile the kernel has 4 cores, so I run the following command:</p><blockquote>make -j4<br/></blockquote><p>At this point you&rsquo;ll want to walk away and get a cup of coffee if you drink it (otherwise, write a blog post).</p><p>The number passed with <i>-j</i> option to make signifies the number of threads you wish make to use for the compilation process (i.e. you should adjust this to be reasonable for the number of cores on your machine). With a 3GB RAM disk and 4 threads, this process takes about <i>15 minutes and 26 seconds</i> on my virtual machine to compile (not bad for a VM on a dinky little laptop).</p><p><b>Install the kernel. </b>Congratulations, you&rsquo;ve successfully built the Linux kernel on your own. Finally, we need to install the kernel so we can actually use it.</p><blockquote>sudo make modules_install install<br/></blockquote><p>This command will put the kernel files alongside your current kernel. When this is done, you should be able to see the kernel files in /boot.</p><h2>Qemu</h2><p>Our kernel is built and now we want to test it. But naturally, we don&rsquo;t want to reboot for every change (and we didn&rsquo;t necessarily install it in the &ldquo;right&rdquo; place to do that, anyway). To do this, we&rsquo;ll use qemu. Q<a href="http://wiki.qemu.org/Main_Page" target="_blank">emu</a> is a pretty nifty little, &ldquo;machine emulator and virtualizer.&rdquo; This tool will allow us to boot up our compiled kernel right in software and observe its behavior. We can similarly attach <i>gdb</i> for debugging this process and it&rsquo;s much faster than performing full reboots on our machine to test the kernel we just built.</p><blockquote><b>NOTE:</b> If you&rsquo;re building a custom kernel for production, it is best to use qemu for prototyping and development, but obviously you should run thorough tests on the bare-metal machines. Since qemu is <i>software </i>that virtualizes the hardware, it is possible that there is a bug in emulation and behavior may vary.<br/></blockquote><p>To load our kernel in qemu, we&rsquo;ll run something similar to the following line:</p><blockquote>qemu-system-x86_64 -kernel /boot/vmlinuz-3.19.0 -initrd /boot/initrd.img-3.19.0 -hda ~/rootfs.img -nographic -serial stdio -append &ldquo;root=/dev/sda console=ttyS0&rdquo;<br/></blockquote><p>This little gem will start qemu and boot your recently built kernel. However, we are missing a piece at this point. Particularly, we have specified a rootfs (root filesystem) image, but we never created it. While the kernel should drop a shell even without the rootfs, it isn&rsquo;t really all that useful without it. I was running this on an ubuntu VM, so we will use &ldquo;qemu-debootstrap&rdquo; to build this for us.</p><blockquote>dd if=/dev/zero of=~/rootfs.img bs=200M count=1<br/>mkfs.ext2 -F ~/rootfs.img<br/>sudo mkdir /mnt/rootfs<br/>sudo mount -o loop ~/rootfs.img /mnt/rootfs<br/>sudo qemu-debootstrap &ndash;arch=i386 precise /mnt/rootfs<br/>sudo cp /etc/passwd /etc/shadow /mnt/rootfs/etc<br/>sync<br/>sudo umount /mnt/rootfs</blockquote><p>This set of commands will create a viable rootfs using ubuntu&rsquo;s &ldquo;precise&rdquo; release as the base distribution. A quick summary follows:</p><ol><li>Create a file of zeros ~200MB in size called <i>rootfs.img</i><br/></li><li>Format <i>rootfs.img</i> to ext2 file system</li><li>Make a mount point for image</li><li>Mount image to created mount point</li><li>Create the rootfs for &ldquo;precise&rdquo; in the mounted location</li><li>Copy over current system user data for login</li><li>Flush file buffers (i.e. make sure we write changes)</li><li>Umount disk image</li></ol><p>As you can see, all of the real work is handled for us by <i>qemu-deboostrap</i>. However, after we have run this, we should now be able to start qemu. After issuing the command above, you should eventually she a login prompt appear in the qemu window. Login with the credentials to your current machine (i.e. we copied /etc/passwd and /etc/shadow) and you should be able to use the system like normal. Similarly, a <i>uname -a</i> should show you that you&rsquo;re running whatever kernel version which you just compiled.</p><h2>Debugging</h2><p>We have successfully built our kernel and loaded it up in our emulator. Next up is debugging. Note that <i>printk</i> (kernel&rsquo;s version of <i>printf</i>) is still very much your friend while working in the kernel, but some things are simply better looked at under the debugger when possible. For this purpose, <a href="https://kgdb.wiki.kernel.org/index.php/Main_Page" target="_blank">KGDB</a> was born and that is why we enabled it earlier. Though the <a href="https://www.kernel.org/doc/htmldocs/kgdb/EnableKGDB.html" target="_blank">official KDB/KGDB docs</a> are quite thorough on this topic, I will summarize here.</p><p><b>Start the kernel.</b> Shutdown your running kernel and modify the boot options slightly. We are going to tell kgdb to send the output to our ttyS0 at 115200 baud:</p><blockquote>qemu-system-x86_64 -kernel /boot/vmlinuz-3.19.0 -initrd /boot/initrd.img-3.19.0 -hda ~/rootfs.img -nographic -serial tcp::4444,server -append &ldquo;root=/dev/sda kgdboc=ttyS0,115200&rdquo;<br/></blockquote><p>Similarly, we change how we will be interacting with our serial port. In particular, we have told qemu to listen on 0.0.0.0 port 4444 for a client until it starts. Since we only have a single serial device, this is now treated as ttyS0 instead of our console. We&rsquo;ll show why this is important later. In any case, you can start your debugger now by simply running:</p><blockquote>gdb &lt;/path/to/kernel/build&gt;/vmlinux<br/>(gdb) target remote 127.0.0.1:4444</blockquote><p>This connects gdb at the network location we told qemu to listen on. Though this is a network connection from the host&rsquo;s perspective, your kernel sees this as a direct <b>serial</b> connection by specifying the <b>-serial</b><i> </i>option.</p><p><b>Drop the kernel into debug mode.</b> The first thing we want to do is actually put the kernel in debug mode. Login as root (or use sudo) and run the following command:</p><blockquote>echo g &gt; /proc/sysrq-trigger<br/></blockquote><p>If you compiled with the KDB frontend and don&rsquo;t have gdb attached, you should see kdb open up in your console. If, however, you followed the steps above and attached with gdb, control of the kernel should have been passed to the debugger. From here, you can operate gdb as you would with any other program.</p><blockquote><b>NOTE:</b> If you have trouble with gdb (i.e. it times out before you drop to debug mode) simply reconnect using the &ldquo;target remote&rdquo; command above. If it appears to be hanging when you first get into debug mode, simply stop debugging the process in gdb (i.e. CTRL + C) and reconnect. You should see a (gdb) prompt when the debugger has successfully connected to the kernel. If you want to continue kernel execution, simply type &ldquo;continue.&rdquo;<br/></blockquote><p>There you have it; a more or less step-by-step guide to building and running your own version of the Linux kernel. This is more useful than just being the coolest kid amongst your friends. With this knowledge you can keep your kernel up-to-date with the latest fixes (before full point releases) and bake in any custom code into your kernel that you find useful. Happy kernel hacking!</p>
